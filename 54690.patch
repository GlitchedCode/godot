From 5704cf42ff0757a7c7e06398895649b07c4ae61e Mon Sep 17 00:00:00 2001
From: Thomas Francis <admin@theorangeday.com>
Date: Sat, 6 Nov 2021 12:14:02 +0000
Subject: [PATCH 1/3] Adding support for shader preprocessing

This revives the preprocessor code from bitsawer and gets it up-to-date with master. I've switched the conditional parsing to use the Expression implementation. I also added support for #ifndef

This also includes code from MagdielM to use his ShaderDependencyGraph code. I made changes to avoid updating previously visited included shaders and switched to use the tokenizer to look for #include uses

Co-Authored-By: bitsawer <22456603+bitsawer@users.noreply.github.com>
Co-Authored-By: Magdiel <56076033+MagdielM@users.noreply.github.com>
---
 editor/plugins/shader_editor_plugin.cpp   |  15 +
 servers/rendering/shader_language.cpp     |  37 +-
 servers/rendering/shader_language.h       |   1 +
 servers/rendering/shader_preprocessor.cpp | 942 ++++++++++++++++++++++
 servers/rendering/shader_preprocessor.h   | 144 ++++
 5 files changed, 1136 insertions(+), 3 deletions(-)
 create mode 100644 servers/rendering/shader_preprocessor.cpp
 create mode 100644 servers/rendering/shader_preprocessor.h

diff --git a/editor/plugins/shader_editor_plugin.cpp b/editor/plugins/shader_editor_plugin.cpp
index 9d2b4c88c558..292ff47716ec 100644
--- a/editor/plugins/shader_editor_plugin.cpp
+++ b/editor/plugins/shader_editor_plugin.cpp
@@ -41,6 +41,7 @@
 #include "editor/property_editor.h"
 #include "servers/display_server.h"
 #include "servers/rendering/shader_types.h"
+#include "servers/rendering/shader_preprocessor.h"
 
 /*** SHADER SCRIPT EDITOR ****/
 
@@ -162,6 +163,18 @@ void ShaderTextEditor::_load_theme_settings() {
 		text_editor->add_auto_brace_completion_pair("/*", "*/");
 	}
 
+	// Colorize shader preprocessor directives
+	List<String> preprocessor_keywords;
+	ShaderPreprocessor::get_keyword_list(&preprocessor_keywords);
+
+	for (List<String>::Element* E = preprocessor_keywords.front(); E; E = E->next()) {
+		syntax_highlighter->add_keyword_color(E->get(), keyword_color);
+	}
+
+	//colorize preprocessor include strings
+	const Color string_color = EDITOR_GET("text_editor/theme/highlighting/string_color");
+	syntax_highlighter->add_color_region("\"", "\"", string_color, false);
+
 	if (warnings_panel) {
 		// Warnings panel
 		warnings_panel->add_theme_font_override("normal_font", EditorNode::get_singleton()->get_gui_base()->get_theme_font(SNAME("main"), SNAME("EditorFonts")));
@@ -545,6 +558,8 @@ void ShaderEditor::apply_shaders() {
 			shader->set_code(editor_code);
 			shader->set_edited(true);
 		}
+
+		ShaderPreprocessor::refresh_shader_dependencies(*shader);
 	}
 }
 
diff --git a/servers/rendering/shader_language.cpp b/servers/rendering/shader_language.cpp
index 04cc844483a1..9517ed19e011 100644
--- a/servers/rendering/shader_language.cpp
+++ b/servers/rendering/shader_language.cpp
@@ -29,6 +29,7 @@
 /*************************************************************************/
 
 #include "shader_language.h"
+#include "shader_preprocessor.h"
 #include "core/os/os.h"
 #include "core/string/print_string.h"
 #include "servers/rendering_server.h"
@@ -7402,6 +7403,24 @@ Error ShaderLanguage::_validate_datatype(DataType p_type) {
 	return OK;
 }
 
+String ShaderLanguage::_preprocess_shader(const String& p_code, Error* p_error) {
+	*p_error = OK;
+
+	ShaderPreprocessor processor(p_code);
+	String processed = processor.preprocess();
+
+	PreprocessorState* state = processor.get_state();
+	if (!state->error.is_empty()) {
+		error_line = state->error_line;
+		error_set = true;
+		error_str = state->error;
+
+		*p_error = FAILED;
+	}
+
+	return processed;
+}
+
 Error ShaderLanguage::_parse_shader(const Map<StringName, FunctionInfo> &p_functions, const Vector<StringName> &p_render_modes, const Set<String> &p_shader_types) {
 	Token tk = _get_token();
 	TkPos prev_pos;
@@ -8961,14 +8980,21 @@ uint32_t ShaderLanguage::get_warning_flags() const {
 Error ShaderLanguage::compile(const String &p_code, const Map<StringName, FunctionInfo> &p_functions, const Vector<StringName> &p_render_modes, const VaryingFunctionNames &p_varying_function_names, const Set<String> &p_shader_types, GlobalVariableGetTypeFunc p_global_variable_type_func) {
 	clear();
 
-	code = p_code;
+	Error err = OK;
+	code = _preprocess_shader(p_code, &err);
+	if (err != OK)
+	{
+		return err;
+	}
+
 	global_var_get_type_func = p_global_variable_type_func;
 	varying_function_names = p_varying_function_names;
 
 	nodes = nullptr;
 
+	char_idx = 0; // reset char idx after preprocess because this compiler exists in a singleton and can be overwritten when called recursively.
 	shader = alloc_node<ShaderNode>();
-	Error err = _parse_shader(p_functions, p_render_modes, p_shader_types);
+	err = _parse_shader(p_functions, p_render_modes, p_shader_types);
 
 #ifdef DEBUG_ENABLED
 	if (check_warnings) {
@@ -8985,7 +9011,12 @@ Error ShaderLanguage::compile(const String &p_code, const Map<StringName, Functi
 Error ShaderLanguage::complete(const String &p_code, const Map<StringName, FunctionInfo> &p_functions, const Vector<StringName> &p_render_modes, const VaryingFunctionNames &p_varying_function_names, const Set<String> &p_shader_types, GlobalVariableGetTypeFunc p_global_variable_type_func, List<ScriptCodeCompletionOption> *r_options, String &r_call_hint) {
 	clear();
 
-	code = p_code;
+	Error err = OK;
+	code = _preprocess_shader(p_code, &err);
+	if (err != OK) {
+		return err;
+	}
+
 	varying_function_names = p_varying_function_names;
 
 	nodes = nullptr;
diff --git a/servers/rendering/shader_language.h b/servers/rendering/shader_language.h
index c82f71d10d14..54d2518a5e04 100644
--- a/servers/rendering/shader_language.h
+++ b/servers/rendering/shader_language.h
@@ -1002,6 +1002,7 @@ class ShaderLanguage {
 	String _get_shader_type_list(const Set<String> &p_shader_types) const;
 	String _get_qualifier_str(ArgumentQualifier p_qualifier) const;
 
+	String _preprocess_shader(const String& p_code, Error* p_error);
 	Error _parse_shader(const Map<StringName, FunctionInfo> &p_functions, const Vector<StringName> &p_render_modes, const Set<String> &p_shader_types);
 
 	Error _find_last_flow_op_in_block(BlockNode *p_block, FlowOperation p_op);
diff --git a/servers/rendering/shader_preprocessor.cpp b/servers/rendering/shader_preprocessor.cpp
new file mode 100644
index 000000000000..81e9b7c0fca2
--- /dev/null
+++ b/servers/rendering/shader_preprocessor.cpp
@@ -0,0 +1,942 @@
+/*************************************************************************/
+/*  shader_preprocessor.cpp                                              */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                      https://godotengine.org                          */
+/*************************************************************************/
+/* Copyright (c) 2007-2021 Juan Linietsky, Ariel Manzur.                 */
+/* Copyright (c) 2014-2021 Godot Engine contributors (cf. AUTHORS.md)    */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+
+#include "shader_preprocessor.h"
+#include "editor/property_editor.h"
+#include "modules/regex/regex.h"
+#include "core/math/expression.h"
+
+static bool is_whitespace(CharType c) {
+	return (c == ' ') || (c == '\t');
+}
+
+static String vector_to_string(const Vector<CharType>& v, int start=0, int end=-1) {
+	const int stop = (end == -1) ? v.size() : end;
+	const int count = stop - start;
+
+	String result;
+	result.resize(count + 1);
+	for (int i = 0; i < count; i++) {
+		result[i] = v[start + i];
+	}
+	result[count] = 0; //Ensure string is null terminated for length() to work
+	return result;
+}
+
+struct PPToken {
+	CharType text;
+	int line;
+
+	PPToken() {
+		text = 0;
+		line = -1;
+	}
+
+	PPToken(CharType p_text, int p_line) {
+		text = p_text;
+		line = p_line;
+	}
+};
+
+static String tokens_to_string(const Vector<PPToken> &tokens) {
+	Vector<CharType> result;
+	for (int i = 0; i < tokens.size(); i++) {
+		result.push_back(tokens[i].text);
+	}
+	return vector_to_string(result);
+}
+
+//Simple processor that can strip away C-like comments from a text
+
+class CommentRemover {
+private:
+	Vector<CharType> stripped;
+	String code;
+	int index;
+	int line;
+	int comment_line_open;
+	int comments_open;
+	int strings_open;
+
+public:
+	CommentRemover(const String &p_code) {
+		code = p_code;
+		index = 0;
+		line = 0;
+		comment_line_open = 0;
+		comments_open = 0;
+		strings_open = 0;
+	}
+
+	String get_error() {
+		if (comments_open != 0) {
+			return "Block comment mismatch";
+		}
+		return "";
+	}
+
+	int get_error_line() {
+		if (comments_open != 0) {
+			return comment_line_open;
+		}
+		return -1;
+	}
+
+	CharType peek() {
+		if (index < code.size()) {
+			return code[index];
+		}
+		return 0;
+	}
+
+	bool advance(CharType what) {
+		while (index < code.size()) {
+			CharType c = code[index++];
+
+			if (c == '\n') {
+				line++;
+				stripped.push_back('\n');
+			}
+
+			if (c == what) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	String strip() {
+		stripped.clear();
+		index = 0;
+		line = 0;
+		comment_line_open = 0;
+		comments_open = 0;
+		strings_open = 0;
+
+		while (index < code.size()) {
+			CharType c = code[index++];
+
+			if (c == '"') {
+				if (strings_open <= 0) {
+					strings_open++;
+				} else {
+					strings_open--;
+				}
+				stripped.push_back(c);
+			} else if (c == '/' && strings_open == 0) {
+				CharType p = peek();
+				if (p == '/') { //Single line comment
+					advance('\n');
+				} else if (p == '*') { //Start of a block comment
+					index++;
+					comment_line_open = line;
+					comments_open++;
+					while (advance('*')) {
+						if (peek() == '/') { //End of a block comment
+							comments_open--;
+							index++;
+							break;
+						}
+					}
+				} else {
+					stripped.push_back(c);
+				}
+			} else if (c == '*' && strings_open == 0) {
+				if (peek() == '/') { //Unmatched end of a block comment
+					comment_line_open = line;
+					comments_open--;
+				} else {
+					stripped.push_back(c);
+				}
+			} else if (c == '\n') {
+				line++;
+				stripped.push_back(c);
+			} else {
+				stripped.push_back(c);
+			}
+		}
+		return vector_to_string(stripped);
+	}
+};
+
+//The real preprocessor that understands basic shader and preprocessor language syntax
+class PreproprocessorTokenizer {
+public:
+	String code;
+	int line;
+	int index;
+	int SIZE;
+	Vector<PPToken> generated;
+
+private:
+	void add_generated(const PPToken &t) {
+		generated.push_back(t);
+	}
+
+	CharType next() {
+		if (index < SIZE) {
+			return code[index++];
+		}
+		return 0;
+	}
+
+public:
+	PreproprocessorTokenizer(String p_code) {
+		code = p_code;
+		line = 0;
+		index = 0;
+		SIZE = code.size();
+	}
+
+	int get_line() {
+		return line;
+	}
+
+	int get_index() {
+		return index;
+	}
+
+	void get_and_clear_generated(Vector<PPToken> *out) {
+		for (int i = 0; i < generated.size(); i++) {
+			out->push_back(generated[i]);
+		}
+		generated.clear();
+	}
+
+	void backtrack(CharType what) {
+		while (index >= 0) {
+			CharType c = code[index];
+			if (c == what) {
+				break;
+			}
+			index--;
+		}
+	}
+
+	CharType peek() {
+		if (index < SIZE) {
+			return code[index];
+		}
+		return 0;
+	}
+
+	Vector<PPToken> advance(CharType what) {
+		Vector<PPToken> tokens;
+
+		while (index < SIZE) {
+			CharType c = code[index++];
+
+			tokens.push_back(PPToken(c, line));
+
+			if (c == '\n') {
+				add_generated(PPToken('\n', line));
+				line++;
+			}
+
+			if (c == what) {
+				return tokens;
+			}
+		}
+		return Vector<PPToken>();
+	}
+
+	void skip_whitespace() {
+		while (is_whitespace(peek())) {
+			next();
+		}
+	}
+
+	String get_identifier() {
+		Vector<CharType> text;
+
+		bool started = false;
+		while (1) {
+			CharType c = peek();
+			if (c == 0 || c == '\n' || c == '(' || c == ')' || c == ',') {
+				break;
+			}
+
+			if (is_whitespace(c) && started) {
+				break;
+			}
+			if (!is_whitespace(c)) {
+				started = true;
+			}
+
+			CharType n = next();
+			if (started) {
+				text.push_back(n);
+			}
+		}
+
+		String id = vector_to_string(text);
+		if (!id.is_valid_identifier()) {
+			return "";
+		}
+
+		return id;
+	}
+
+	String peek_identifier() {
+		const int original = index;
+		String id = get_identifier();
+		index = original;
+		return id;
+	}
+
+	PPToken get_token() {
+		while (index < SIZE) {
+			const CharType c = code[index++];
+			const PPToken t = PPToken(c, line);
+
+			switch (c) {
+				case ' ':
+				case '\t':
+					skip_whitespace();
+					return PPToken(' ', line);
+				case '\n':
+					line++;
+					return t;
+				default:
+					return t;
+			}
+		}
+		return PPToken(0, line);
+	}
+};
+
+ShaderPreprocessor::~ShaderPreprocessor() {
+	free_state();
+}
+
+ShaderPreprocessor::ShaderPreprocessor(const String &p_code) {
+	code = p_code;
+	state = NULL;
+	state_owner = false;
+}
+
+String ShaderPreprocessor::preprocess(PreprocessorState *p_state) {
+	free_state();
+
+	output.clear();
+
+	state = p_state;
+	if (state == NULL) {
+		state = create_state();
+		state_owner = true;
+	}
+
+	CommentRemover remover(code);
+	String stripped = remover.strip();
+	String error = remover.get_error();
+	if (!error.is_empty()) {
+		set_error(error, remover.get_error_line());
+		return "<error>";
+	}
+
+	PreproprocessorTokenizer tokenizer(stripped);
+	int last_size = 0;
+
+	while (1) {
+		const PPToken &t = tokenizer.get_token();
+
+		//Add autogenerated tokens
+		Vector<PPToken> generated;
+		tokenizer.get_and_clear_generated(&generated);
+		for (int i = 0; i < generated.size(); i++) {
+			output.push_back(generated[i].text);
+		}
+
+		if (t.text == 0) {
+			break;
+		}
+
+		if (t.text == '#') { //TODO check if at the beginning of line
+			process_directive(&tokenizer);
+		} else {
+			if (t.text == '\n') {
+				expand_output_macros(last_size, tokenizer.get_line());
+				last_size = output.size();
+			}
+			output.push_back(t.text);
+		}
+
+		if (!state->error.is_empty()) {
+			return "<error>";
+		}
+	}
+
+	expand_output_macros(last_size, tokenizer.get_line());
+
+	String result = vector_to_string(output);
+
+	
+	/*print_line("--------------------------------------");
+	print_line("Preprocessed shader:");
+	print_line(result);
+	print_line("--------------------------------------");*/
+	
+
+	return result;
+}
+
+void ShaderPreprocessor::process_directive(PreproprocessorTokenizer *tokenizer) {
+	String directive = tokenizer->get_identifier();
+
+	if (directive == "if") {
+		process_if(tokenizer);
+	} else if (directive == "ifdef") {
+		process_ifdef(tokenizer);
+	} else if (directive == "ifndef") {
+		process_ifndef(tokenizer);
+	} else if (directive == "else") {
+		process_else(tokenizer);
+	} else if (directive == "endif") {
+		process_endif(tokenizer);
+	} else if (directive == "define") {
+		process_define(tokenizer);
+	} else if (directive == "undef") {
+		process_undef(tokenizer);
+	} else if (directive == "include") {
+		process_include(tokenizer);
+	} else {
+		set_error("Unknown directive", tokenizer->get_line());
+	}
+}
+
+void ShaderPreprocessor::process_if(PreproprocessorTokenizer* tokenizer) {
+	int line = tokenizer->get_line();
+
+	String body = tokens_to_string(tokenizer->advance('\n')).strip_edges();
+	if (body.is_empty()) {
+		set_error("Missing condition", line);
+		return;
+	}
+
+	body = expand_macros(body, line);
+	if (!state->error.is_empty()) {
+		return;
+	}
+
+	double value = 1.0;
+	Expression expression;
+	Vector<String> names;
+	Error error = expression.parse(body, names);
+	if (error != OK)
+	{
+		set_error(expression.get_error_text(), line);
+		return;
+	}
+
+	Variant v = expression.execute(Array(), NULL, false);
+	if (v.get_type() == Variant::NIL) {
+		set_error("Condition evaluation error", line);
+		return;
+	}
+
+	bool success = v.booleanize();
+	start_branch_condition(tokenizer, success);
+}
+
+void ShaderPreprocessor::process_ifdef(PreproprocessorTokenizer *tokenizer) {
+	const int line = tokenizer->get_line();
+
+	String label = tokenizer->get_identifier();
+	if (label.is_empty()) {
+		set_error("Invalid macro name", line);
+		return;
+	}
+
+	tokenizer->skip_whitespace();
+	if (tokenizer->peek() != '\n') {
+		set_error("Invalid ifdef", line);
+		return;
+	}
+	tokenizer->advance('\n');
+
+	bool success = state->defines.has(label);
+	start_branch_condition(tokenizer, success);
+}
+
+void ShaderPreprocessor::process_ifndef(PreproprocessorTokenizer* tokenizer) {
+	const int line = tokenizer->get_line();
+
+	String label = tokenizer->get_identifier();
+	if (label.is_empty()) {
+		set_error("Invalid macro name", line);
+		return;
+	}
+
+	tokenizer->skip_whitespace();
+	if (tokenizer->peek() != '\n') {
+		set_error("Invalid ifndef", line);
+		return;
+	}
+	tokenizer->advance('\n');
+
+	bool success = !state->defines.has(label);
+	start_branch_condition(tokenizer, success);
+}
+
+void ShaderPreprocessor::start_branch_condition(PreproprocessorTokenizer *tokenizer, bool success) {
+	state->condition_depth++;
+
+	if (success) {
+		state->skip_stack_else.push_back(true);
+	} else {
+		Vector<String> ends;
+		ends.push_back("else");
+		ends.push_back("endif");
+		if (next_directive(tokenizer, ends) == "else") {
+			state->skip_stack_else.push_back(false);
+		} else {
+			state->skip_stack_else.push_back(true);
+		}
+	}
+}
+
+void ShaderPreprocessor::process_else(PreproprocessorTokenizer *tokenizer) {
+	if (state->skip_stack_else.is_empty()) {
+		set_error("Unmatched else", tokenizer->get_line());
+		return;
+	}
+	tokenizer->advance('\n');
+
+	bool skip = state->skip_stack_else[state->skip_stack_else.size() - 1];
+	state->skip_stack_else.remove(state->skip_stack_else.size() - 1);
+
+	if (skip) {
+		Vector<String> ends;
+		ends.push_back("endif");
+		next_directive(tokenizer, ends);
+	}
+}
+
+void ShaderPreprocessor::process_endif(PreproprocessorTokenizer *tokenizer) {
+	state->condition_depth--;
+	if (state->condition_depth < 0) {
+		set_error("Unmatched endif", tokenizer->get_line());
+		return;
+	}
+	tokenizer->advance('\n');
+}
+
+void ShaderPreprocessor::process_define(PreproprocessorTokenizer *tokenizer) {
+	const int line = tokenizer->get_line();
+
+	String label = tokenizer->get_identifier();
+	if (label.is_empty()) {
+		set_error("Invalid macro name", line);
+		return;
+	}
+
+	if (state->defines.has(label)) {
+		set_error("Macro redefinition", line);
+		return;
+	}
+
+	if (tokenizer->peek() == '(') {
+		//Macro has arguments
+		tokenizer->get_token();
+
+		Vector<String> args;
+		while (1) {
+			String name = tokenizer->get_identifier();
+			if (name.is_empty()) {
+				set_error("Invalid argument name", line);
+				return;
+			}
+			args.push_back(name);
+
+			tokenizer->skip_whitespace();
+			CharType next = tokenizer->get_token().text;
+			if (next == ')') {
+				break;
+			} else if (next != ',') {
+				set_error("Expected a comma in the macro argument list", line);
+				return;
+			}
+		}
+
+		PreprocessorDefine *define = memnew(PreprocessorDefine);
+		define->arguments = args;
+		define->body = tokens_to_string(tokenizer->advance('\n')).strip_edges();
+		state->defines[label] = define;
+	} else {
+		//Simple substitution macro
+		PreprocessorDefine *define = memnew(PreprocessorDefine);
+		define->body = tokens_to_string(tokenizer->advance('\n')).strip_edges();
+		state->defines[label] = define;
+	}
+}
+
+void ShaderPreprocessor::process_undef(PreproprocessorTokenizer *tokenizer) {
+	const int line = tokenizer->get_line();
+	const String label = tokenizer->get_identifier();
+	if (label.is_empty()) {
+		set_error("Invalid name", line);
+		return;
+	}
+
+	tokenizer->skip_whitespace();
+	if (tokenizer->peek() != '\n') {
+		set_error("Invalid undef", line);
+		return;
+	}
+
+	state->defines.erase(label);
+}
+
+void ShaderPreprocessor::process_include(PreproprocessorTokenizer *tokenizer) {
+	const int line = tokenizer->get_line();
+
+	tokenizer->advance('"');
+	String path = tokens_to_string(tokenizer->advance('"'));
+	path.erase(path.length() - 1, 1);
+	tokenizer->skip_whitespace();
+
+	if (path.is_empty()/* || tokenizer->peek() != '\n'*/) {
+		set_error("Invalid path", line);
+		return;
+	}
+
+	RES res = ResourceLoader::load(path);
+	if (res.is_null()) {
+		set_error("Shader include load failed", line);
+		return;
+	}
+
+	Shader *shader = Object::cast_to<Shader>(*res);
+	if (shader == NULL) {
+		set_error("Shader include resource type is wrong", line);
+		return;
+	}
+
+	String included = shader->get_code();
+	if (included.is_empty()) {
+		set_error("Shader include not found", line);
+		return;
+	}
+
+	int type_end = included.find(";");
+	if (type_end == -1) {
+		set_error("Shader include shader_type not found", line);
+		return;
+	}
+
+	const String real_path = shader->get_path();
+	if (state->includes.has(real_path)) {
+		//Already included, skip.
+		return;
+	}
+
+	//Mark as included
+	state->includes.insert(real_path);
+
+	state->include_depth++;
+	if (state->include_depth > 25) {
+		set_error("Shader max include depth exceeded", line);
+		return;
+	}
+
+	//Remove "shader_type xyz;" prefix from included files
+	included = included.substr(type_end + 1, included.length());
+
+	ShaderPreprocessor processor(included);
+	String result = processor.preprocess(state).replace("\n", " "); //To preserve line numbers cram everything into a single line
+	add_to_output(result);
+
+	if (!state->error.is_empty() && state_owner) {
+		//This is the root file, so force the line number to match this instead of the included file
+		state->error_line = line + 1;
+	}
+
+	state->include_depth--;
+}
+
+void ShaderPreprocessor::expand_output_macros(int start, int line_number) {
+	String line = vector_to_string(output, start, output.size());
+
+	line = expand_macros(line, line_number - 1); //We are already on next line, so -1
+
+	output.resize(start);
+
+	add_to_output(line);
+}
+
+String ShaderPreprocessor::expand_macros(const String &p_string, int p_line) {
+	String result = p_string;
+
+	int expanded = 1;
+	while (expanded) {
+		result = expand_macros_once(result, p_line, &expanded);
+
+		if (!state->error.is_empty()) {
+			return "<error>";
+		}
+	}
+	return result;
+}
+
+String ShaderPreprocessor::expand_macros_once(const String &p_line, int line_number, int *p_expanded) {
+	String result = p_line;
+	*p_expanded = 0;
+
+	//TODO Could use something better than regular expressions for this...
+	for (const Map<String, PreprocessorDefine *>::Element *E = state->defines.front(); E; E = E->next()) {
+		const String &key = E->key();
+		const PreprocessorDefine *define = E->get();
+
+		//Match against word boundaries
+		RegEx label("\\b" + key + "\\b");
+
+		Ref<RegExMatch> match = label.search(result);
+		if (match.is_valid()) {
+			//Substitute all macro content
+			if (define->arguments.size() > 0) {
+				//Complex macro with arguments
+				int args_start = match->get_end(0);
+				int args_end = p_line.find(")", args_start);
+				if (args_start == -1 || args_end == -1) {
+					*p_expanded = 0;
+					set_error("Missing macro argument parenthesis", line_number);
+					return "<error>";
+				}
+
+				String values = result.substr(args_start + 1, args_end - (args_start + 1));
+				Vector<String> args = values.split(",");
+				if (args.size() != define->arguments.size()) {
+					*p_expanded = 0;
+					set_error("Invalid macro argument count", line_number);
+					return "<error>";
+				}
+				//Insert macro arguments into the body
+				String body = define->body;
+				for (int i = 0; i < args.size(); i++) {
+					RegEx value("\\b" + define->arguments[i] + "\\b");
+					body = value.sub(body, args[i], true);
+				}
+
+				result = result.substr(0, match->get_start(0)) + " " + body + " " + result.substr(args_end + 1, result.length());
+			} else {
+				//Simple substitution macro
+				result = label.sub(result, define->body, true);
+			}
+
+			*p_expanded = 1;
+		}
+	}
+	return result;
+}
+
+String ShaderPreprocessor::next_directive(PreproprocessorTokenizer *tokenizer, const Vector<String> &directives) {
+	const int line = tokenizer->get_line();
+	int nesting = 0;
+
+	while (1) {
+		tokenizer->advance('#');
+
+		String id = tokenizer->peek_identifier();
+		if (id.is_empty()) {
+			break;
+		}
+
+		if (nesting == 0) {
+			for (int i = 0; i < directives.size(); i++) {
+				if (directives[i] == id) {
+					tokenizer->backtrack('#');
+					return id;
+				}
+			}
+		}
+
+		if (id == "ifdef" || id == "ifndef" || id == "if") {
+			nesting++;
+		} else if (id == "endif") {
+			nesting--;
+		}
+	}
+
+	set_error("Can't find matching branch directive", line);
+	return "";
+}
+
+void ShaderPreprocessor::add_to_output(const String &p_str) {
+	for (int i = 0; i < p_str.length(); i++) {
+		output.push_back(p_str[i]);
+	}
+}
+
+void ShaderPreprocessor::set_error(const String &error, int line) {
+	if (state->error.is_empty()) {
+		state->error = error;
+		state->error_line = line + 1;
+	}
+}
+
+void ShaderPreprocessor::free_state() {
+	if (state_owner && state != NULL) {
+		for (const Map<String, PreprocessorDefine *>::Element *E = state->defines.front(); E; E = E->next()) {
+			memdelete(E->get());
+		}
+		memdelete(state);
+	}
+	state_owner = false;
+	state = NULL;
+}
+
+PreprocessorDefine *create_define(const String &body) {
+	PreprocessorDefine *define = memnew(PreprocessorDefine);
+	define->body = body;
+	return define;
+}
+
+PreprocessorState *ShaderPreprocessor::create_state() {
+	PreprocessorState *new_state = memnew(PreprocessorState);
+	new_state->condition_depth = 0;
+	new_state->include_depth = 0;
+	new_state->error = "";
+	new_state->error_line = -1;
+
+	OS *os = OS::get_singleton();
+
+	String platform = os->get_name().replace(" ", "_").to_upper();
+	new_state->defines[platform] = create_define("true");
+
+	Engine *engine = Engine::get_singleton();
+	new_state->defines["EDITOR"] = create_define(engine->is_editor_hint() ? "true" : "false");
+
+	return new_state;
+}
+
+void ShaderPreprocessor::get_keyword_list(List<String> *keywords) {
+	keywords->push_back("include");
+	keywords->push_back("define");
+	keywords->push_back("undef");
+	//keywords->push_back("if");  //Already a keyword
+	keywords->push_back("ifdef");
+	keywords->push_back("ifndef");
+	//keywords->push_back("else"); //Already a keyword
+	keywords->push_back("endif");
+}
+
+void ShaderPreprocessor::refresh_shader_dependencies(Ref<Shader> shader) {
+	ShaderDependencyGraph shaderDependencies;
+	shaderDependencies.populate(shader);
+	shaderDependencies.update_shaders();
+}
+
+ShaderDependencyGraph::~ShaderDependencyGraph() {
+	for (auto E = nodes.front(); E; E = E->next()) {
+		delete E->get();
+	}
+}
+
+ShaderDependencyNode::ShaderDependencyNode(Ref<Shader> s) :
+	shader(s) {}
+
+ShaderDependencyNode::~ShaderDependencyNode() {
+	for (auto E = dependencies.front(); E; E = E->next()) {
+		delete E->get();
+	}
+}
+
+bool operator<(ShaderDependencyNode left, ShaderDependencyNode right) {
+	return left.shader < right.shader;
+}
+
+bool operator==(ShaderDependencyNode left, ShaderDependencyNode right) {
+	return left.shader == right.shader;
+}
+
+void ShaderDependencyGraph::populate(Ref<Shader> shader) {
+	cyclic_dep_tracker.clear();
+	ShaderDependencyNode* node = new ShaderDependencyNode(shader);
+	nodes.insert(node);
+	populate(node);
+}
+
+void ShaderDependencyGraph::populate(ShaderDependencyNode* node) {
+	ERR_FAIL_COND_MSG(cyclic_dep_tracker.find(node), vformat("Shader %s contains a cyclic import. Skipping...", node->shader->get_name()));
+
+	cyclic_dep_tracker.push_back(node);
+	String code = CommentRemover(node->shader->get_code()).strip(); // Build dependency graph starting from edited shader. Strip comments
+
+	PreproprocessorTokenizer tokenizer(code);
+	while(1) {
+		if (!tokenizer.advance('#').is_empty()) {
+			String directive = tokenizer.get_identifier();
+			if (directive == "include") {
+				tokenizer.advance('"');
+				String path = tokens_to_string(tokenizer.advance('"'));
+				path.erase(path.length() - 1, 1);
+				tokenizer.skip_whitespace();
+				Ref<Shader> shader_reference = Object::cast_to<Shader>(*ResourceLoader::load(path));
+
+				// skip this shader if we've picked it up as a dependency already
+				if (!visited_shaders.find(shader_reference)) {
+					ShaderDependencyNode* new_node = new ShaderDependencyNode(shader_reference);
+					visited_shaders.push_back(new_node->shader);
+					populate(new_node);
+					node->dependencies.insert(new_node);
+				}
+			}
+		}
+		else {
+			break;
+		}
+	}
+
+	cyclic_dep_tracker.erase(node);
+}
+
+Set<ShaderDependencyNode*>::Element* ShaderDependencyGraph::find(Ref<Shader> shader) {
+	for (auto E = nodes.front(); E; E = E->next()) {
+		if (E->get()->shader == shader) {
+			return E;
+		}
+	}
+
+	return nullptr;
+}
+
+void ShaderDependencyGraph::update_shaders() {
+	for (auto E = nodes.front(); E; E = E->next()) {
+		update_shaders(E->get());
+	}
+}
+
+void ShaderDependencyGraph::update_shaders(ShaderDependencyNode* node) {
+	for (auto E = node->dependencies.front(); E; E = E->next()) {
+		update_shaders(E->get());
+	}
+
+	node->shader->set_code(node->shader->get_code());
+}
diff --git a/servers/rendering/shader_preprocessor.h b/servers/rendering/shader_preprocessor.h
new file mode 100644
index 000000000000..87eae71fa72f
--- /dev/null
+++ b/servers/rendering/shader_preprocessor.h
@@ -0,0 +1,144 @@
+/*************************************************************************/
+/*  shader_preprocessor.h                                                */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                      https://godotengine.org                          */
+/*************************************************************************/
+/* Copyright (c) 2007-2021 Juan Linietsky, Ariel Manzur.                 */
+/* Copyright (c) 2014-2021 Godot Engine contributors (cf. AUTHORS.md)    */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+
+#ifndef SHADER_PREPROCESSOR_H
+#define SHADER_PREPROCESSOR_H
+
+#include "core/templates/list.h"
+#include "core/templates/map.h"
+#include "core/templates/set.h"
+#include "core/typedefs.h"
+#include "core/string/ustring.h"
+
+#include "core/io/resource_loader.h"
+#include "core/os/os.h"
+#include "scene/resources/shader.h"
+
+class PreproprocessorTokenizer;
+class PPToken;
+
+typedef char CharType;
+
+struct PreprocessorDefine {
+	Vector<String> arguments;
+	String body;
+};
+
+struct PreprocessorState {
+	Map<String, PreprocessorDefine *> defines;
+	Vector<bool> skip_stack_else;
+	int condition_depth;
+	Set<String> includes;
+	int include_depth;
+	String error;
+	int error_line;
+};
+
+class ShaderPreprocessor {
+
+public:
+	~ShaderPreprocessor();
+	ShaderPreprocessor(const String &p_code);
+
+	String preprocess(PreprocessorState *p_state);
+	String preprocess() { return preprocess(NULL); }
+
+	PreprocessorState *get_state() { return state; }
+
+	static void get_keyword_list(List<String> *keywords);
+
+	static void refresh_shader_dependencies(Ref<Shader> shader);
+
+private:
+	void process_directive(PreproprocessorTokenizer *);
+
+	void process_if(PreproprocessorTokenizer *);
+	void process_ifdef(PreproprocessorTokenizer *);
+	void process_ifndef(PreproprocessorTokenizer*);
+	void start_branch_condition(PreproprocessorTokenizer *tokenizer, bool success);
+
+	void process_else(PreproprocessorTokenizer *);
+	void process_endif(PreproprocessorTokenizer *);
+
+	void process_define(PreproprocessorTokenizer *);
+	void process_undef(PreproprocessorTokenizer *);
+	void process_include(PreproprocessorTokenizer *);
+
+	void expand_output_macros(int start, int line);
+	String expand_macros(const String &p_string, int p_line);
+	String expand_macros_once(const String &p_line, int line, int *p_expanded);
+
+	String evaluate_internal_conditions(const String& p_string, int p_line);
+
+	String next_directive(PreproprocessorTokenizer *tokenizer, const Vector<String> &directives);
+	void add_to_output(const String &p_str);
+	void set_error(const String &error, int line);
+
+	static PreprocessorState *create_state();
+	void free_state();
+
+	String code;
+	Vector<CharType> output;
+	PreprocessorState *state;
+	bool state_owner;
+};
+
+struct ShaderDependencyNode {
+	Ref<Shader> shader;
+	Set<ShaderDependencyNode*> dependencies;
+
+	ShaderDependencyNode() = default;
+	ShaderDependencyNode(Ref<Shader>);
+
+	~ShaderDependencyNode();
+
+	friend bool operator<(ShaderDependencyNode, ShaderDependencyNode);
+	friend bool operator==(ShaderDependencyNode, ShaderDependencyNode);
+};
+
+class ShaderDependencyGraph {
+public:
+	~ShaderDependencyGraph();
+
+	Set<ShaderDependencyNode*> nodes;
+
+	void populate(Ref<Shader>);
+	void update_shaders();
+
+private:
+	List<ShaderDependencyNode*> cyclic_dep_tracker;
+	List<Ref<Shader>> visited_shaders;
+
+	Set<ShaderDependencyNode*>::Element* find(Ref<Shader>);
+	void populate(ShaderDependencyNode*);
+	void update_shaders(ShaderDependencyNode*);
+};
+
+#endif

From be1dac84a55703a786323088c7cf0c46daa89087 Mon Sep 17 00:00:00 2001
From: Thomas Francis <admin@theorangeday.com>
Date: Sat, 6 Nov 2021 23:27:42 +0000
Subject: [PATCH 2/3] Updating preprocessor comment stripping to ignore invalid
 characters and updated the shader dependency parser to be safer when code is
 pulled during mid-authoring

---
 servers/rendering/shader_preprocessor.cpp | 36 +++++++++++++++--------
 1 file changed, 23 insertions(+), 13 deletions(-)

diff --git a/servers/rendering/shader_preprocessor.cpp b/servers/rendering/shader_preprocessor.cpp
index 81e9b7c0fca2..dbced65b6b82 100644
--- a/servers/rendering/shader_preprocessor.cpp
+++ b/servers/rendering/shader_preprocessor.cpp
@@ -143,7 +143,10 @@ class CommentRemover {
 		while (index < code.size()) {
 			CharType c = code[index++];
 
-			if (c == '"') {
+			if (c < 0) {
+				// skip invalid chars.
+				continue;
+			} else if (c == '"') {
 				if (strings_open <= 0) {
 					strings_open++;
 				} else {
@@ -894,18 +897,25 @@ void ShaderDependencyGraph::populate(ShaderDependencyNode* node) {
 		if (!tokenizer.advance('#').is_empty()) {
 			String directive = tokenizer.get_identifier();
 			if (directive == "include") {
-				tokenizer.advance('"');
-				String path = tokens_to_string(tokenizer.advance('"'));
-				path.erase(path.length() - 1, 1);
-				tokenizer.skip_whitespace();
-				Ref<Shader> shader_reference = Object::cast_to<Shader>(*ResourceLoader::load(path));
-
-				// skip this shader if we've picked it up as a dependency already
-				if (!visited_shaders.find(shader_reference)) {
-					ShaderDependencyNode* new_node = new ShaderDependencyNode(shader_reference);
-					visited_shaders.push_back(new_node->shader);
-					populate(new_node);
-					node->dependencies.insert(new_node);
+				if (!tokenizer.advance('"').is_empty()) {
+					String path = tokens_to_string(tokenizer.advance('"'));
+					path.erase(path.length() - 1, 1);
+					tokenizer.skip_whitespace();
+					if (!path.is_empty()) {
+						RES res = ResourceLoader::load(path);
+						if (!res.is_null())
+						{
+							Ref<Shader> shader_reference = Object::cast_to<Shader>(*res);
+
+							// skip this shader if we've picked it up as a dependency already
+							if (shader_reference != nullptr && !visited_shaders.find(shader_reference)) {
+								ShaderDependencyNode* new_node = new ShaderDependencyNode(shader_reference);
+								visited_shaders.push_back(new_node->shader);
+								populate(new_node);
+								node->dependencies.insert(new_node);
+							}
+						}
+					}
 				}
 			}
 		}

From f8d0deba51ffc705aad147348e2ea88d2ab41f07 Mon Sep 17 00:00:00 2001
From: Thomas Francis <admin@theorangeday.com>
Date: Tue, 9 Nov 2021 21:29:17 +0000
Subject: [PATCH 3/3] Adding support for shader dependency graph as a tree
 within the shader editor directly

This primes the editor for better editing and error contexts. This can also be expanded to enhance the highlighting of code because you'll see the code that's included in full dependency context based on available defines (that work is pending)

Also fixing forward declare issue (used class instead of struct, this was causing a build error with "warnings as errors")
---
 editor/plugins/shader_editor_plugin.cpp   | 133 +++++++++++++++++++++-
 editor/plugins/shader_editor_plugin.h     |  17 +++
 servers/rendering/shader_preprocessor.cpp |   3 +
 servers/rendering/shader_preprocessor.h   |   2 +-
 4 files changed, 149 insertions(+), 6 deletions(-)

diff --git a/editor/plugins/shader_editor_plugin.cpp b/editor/plugins/shader_editor_plugin.cpp
index 292ff47716ec..63c0e685eaa4 100644
--- a/editor/plugins/shader_editor_plugin.cpp
+++ b/editor/plugins/shader_editor_plugin.cpp
@@ -55,6 +55,10 @@ Ref<Shader> ShaderTextEditor::get_edited_shader() const {
 }
 
 void ShaderTextEditor::set_edited_shader(const Ref<Shader> &p_shader) {
+	set_edited_shader(p_shader, p_shader->get_code());
+}
+
+void ShaderTextEditor::set_edited_shader(const Ref<Shader>& p_shader, String code) {
 	if (shader == p_shader) {
 		return;
 	}
@@ -62,7 +66,7 @@ void ShaderTextEditor::set_edited_shader(const Ref<Shader> &p_shader) {
 
 	_load_theme_settings();
 
-	get_text_editor()->set_text(p_shader->get_code());
+	get_text_editor()->set_text(code);
 	get_text_editor()->clear_undo_history();
 	get_text_editor()->call_deferred(SNAME("set_h_scroll"), 0);
 	get_text_editor()->call_deferred(SNAME("set_v_scroll"), 0);
@@ -95,6 +99,10 @@ void ShaderTextEditor::set_warnings_panel(RichTextLabel *p_warnings_panel) {
 	warnings_panel = p_warnings_panel;
 }
 
+void ShaderTextEditor::set_shader_dependency_tree(Tree* tree) {
+	shader_dependency_tree = tree;
+}
+
 void ShaderTextEditor::_load_theme_settings() {
 	CodeEdit *text_editor = get_text_editor();
 	Color updated_marked_line_color = EDITOR_GET("text_editor/theme/highlighting/mark_color");
@@ -529,6 +537,15 @@ void ShaderEditor::edit(const Ref<Shader> &p_shader) {
 
 	shader = p_shader;
 
+	// create shader dependencies and update tree.
+	// TODO need to call this on edit as well. if the script changes there could be new dpendencies.
+	// this needs to be updated constantly
+	shader_rolling_code.clear();
+	shader_dependencies.populate(shader);
+	_update_shader_dependency_tree();
+
+	shader_rolling_code[shader->get_path()] = p_shader->get_code();
+
 	shader_editor->set_edited_shader(p_shader);
 
 	//vertex_editor->set_edited_shader(shader,ShaderLanguage::SHADER_MATERIAL_VERTEX);
@@ -553,10 +570,23 @@ void ShaderEditor::save_external_data(const String &p_str) {
 void ShaderEditor::apply_shaders() {
 	if (shader.is_valid()) {
 		String shader_code = shader->get_code();
-		String editor_code = shader_editor->get_text_editor()->get_text();
-		if (shader_code != editor_code) {
-			shader->set_code(editor_code);
-			shader->set_edited(true);
+
+		// shader_rolling_code
+
+		Ref<Shader> currently_edited_shader = shader_editor->get_edited_shader();
+		if (currently_edited_shader == shader)
+		{
+			String editor_code = shader_editor->get_text_editor()->get_text(); // TODO get cached version of root node shader code to apply. Then set all dep code too. Do this in reverse order up the tree?
+			if (shader_code != editor_code) {
+				shader->set_code(editor_code);
+				shader->set_edited(true);
+			}
+		}
+		else
+		{
+			String editor_code = shader_editor->get_text_editor()->get_text();
+			currently_edited_shader->set_code(editor_code);
+			currently_edited_shader->set_edited(true);
 		}
 
 		ShaderPreprocessor::refresh_shader_dependencies(*shader);
@@ -664,6 +694,80 @@ void ShaderEditor::_make_context_menu(bool p_selection, Vector2 p_position) {
 	context_menu->popup();
 }
 
+void ShaderEditor::_tree_activate_shader()
+{
+	TreeItem *selected = shader_dependency_tree->get_selected();
+	if (selected) {
+		String path = selected->get_metadata(0);
+
+		auto rollingCode = shader_rolling_code.find(path);
+
+		if (rollingCode)
+		{
+			RES res = ResourceLoader::load(path);
+			if (!res.is_null()) {
+				Shader* shader = Object::cast_to<Shader>(*res);
+				if (shader != nullptr) {
+					shader_editor->set_edited_shader(shader, rollingCode->get());
+				}
+			}
+		}
+		else
+		{
+			// TODO pull from shader dependency graph which can hold cache data, or store directly in tree?
+			// using only to pull code. how to cache data? hash set in editor panel with path lookup?
+			RES res = ResourceLoader::load(path);
+			if (!res.is_null()) {
+				Shader* shader = Object::cast_to<Shader>(*res);
+				if (shader != nullptr) {
+					String included = shader->get_code();
+					shader_rolling_code[path] = included;
+					shader_editor->set_edited_shader(shader);
+				}
+			}
+		}
+
+		/*TreeItem* parent = selected->get_parent();
+		bool is_favorite = parent != nullptr && parent->get_metadata(0) == "Favorites";
+
+		if ((!is_favorite && path.ends_with("/")) || path == "Favorites") {
+			bool collapsed = selected->is_collapsed();
+			selected->set_collapsed(!collapsed);
+		}
+		else {
+			_select_file(path, is_favorite && !path.ends_with("/"));
+		}*/
+	}
+}
+
+void ShaderEditor::_update_shader_dependency_tree()
+{
+	shader_dependency_tree->clear();
+	TreeItem *root = shader_dependency_tree->create_item();
+	root->select(0);
+
+	for (ShaderDependencyNode *node : shader_dependencies.nodes) {
+		TreeItem *shader_parent_item = shader_dependency_tree->create_item(root);
+		shader_parent_item->set_text(0, TTR(node->shader->get_path()));
+		shader_parent_item->set_metadata(0, node->shader->get_path());
+		shader_parent_item->set_icon(0, get_theme_icon(SNAME("Shader"), SNAME("EditorIcons")));
+
+		_update_shader_dependency_tree_items(shader_parent_item, node);
+	}
+}
+
+void ShaderEditor::_update_shader_dependency_tree_items(TreeItem* parent_tree_item, ShaderDependencyNode* node)
+{
+	for (ShaderDependencyNode *child_node : node->dependencies) {
+		TreeItem *shader_child_item = shader_dependency_tree->create_item(parent_tree_item);
+		shader_child_item->set_text(0, TTR(child_node->shader->get_path()));
+		shader_child_item->set_metadata(0, child_node->shader->get_path());
+		shader_child_item->set_icon(0, get_theme_icon(SNAME("Shader"), SNAME("EditorIcons")));
+
+		_update_shader_dependency_tree_items(shader_child_item, child_node);
+	}
+}
+
 ShaderEditor::ShaderEditor(EditorNode *p_node) {
 	GLOBAL_DEF("debug/shader_language/warnings/enable", true);
 	GLOBAL_DEF("debug/shader_language/warnings/treat_warnings_as_errors", false);
@@ -694,7 +798,26 @@ ShaderEditor::ShaderEditor(EditorNode *p_node) {
 	add_child(context_menu);
 	context_menu->connect("id_pressed", callable_mp(this, &ShaderEditor::_menu_option));
 
+	HSplitContainer* panel_split = memnew(HSplitContainer);
+	panel_split->set_anchors_and_offsets_preset(Control::PRESET_WIDE);
+	panel_split->set_v_size_flags(SIZE_EXPAND_FILL);
+	add_child(panel_split);
+
 	VBoxContainer *main_container = memnew(VBoxContainer);
+	panel_split->add_child(main_container);
+
+	shader_dependency_tree = memnew(Tree);
+	shader_dependency_tree->set_hide_root(true);
+	shader_dependency_tree->set_allow_rmb_select(true);
+	shader_dependency_tree->set_select_mode(Tree::SELECT_SINGLE);
+	// shader_dependency_tree->set_custom_minimum_size(Size2(0, 15 * EDSCALE));
+
+	shader_dependency_tree->connect("item_activated", callable_mp(this, &ShaderEditor::_tree_activate_shader));
+
+	panel_split->add_child(shader_dependency_tree);
+	shader_editor->set_shader_dependency_tree(shader_dependency_tree);
+	
+
 	HBoxContainer *hbc = memnew(HBoxContainer);
 
 	edit_menu = memnew(MenuButton);
diff --git a/editor/plugins/shader_editor_plugin.h b/editor/plugins/shader_editor_plugin.h
index 77579754d3c1..1b7931792e85 100644
--- a/editor/plugins/shader_editor_plugin.h
+++ b/editor/plugins/shader_editor_plugin.h
@@ -38,9 +38,11 @@
 #include "scene/gui/rich_text_label.h"
 #include "scene/gui/tab_container.h"
 #include "scene/gui/text_edit.h"
+#include "scene/gui/tree.h"
 #include "scene/main/timer.h"
 #include "scene/resources/shader.h"
 #include "servers/rendering/shader_language.h"
+#include "servers/rendering/shader_preprocessor.h"
 
 class ShaderTextEditor : public CodeTextEditor {
 	GDCLASS(ShaderTextEditor, CodeTextEditor);
@@ -53,11 +55,13 @@ class ShaderTextEditor : public CodeTextEditor {
 
 	Ref<CodeHighlighter> syntax_highlighter;
 	RichTextLabel *warnings_panel = nullptr;
+	Tree *shader_dependency_tree;
 	Ref<Shader> shader;
 	List<ShaderWarning> warnings;
 
 	void _check_shader_mode();
 	void _update_warning_panel();
+	void _update_shader_dependency_tree_items(TreeItem* parent_tree_item, ShaderDependencyNode* node);
 
 protected:
 	static void _bind_methods();
@@ -71,8 +75,13 @@ class ShaderTextEditor : public CodeTextEditor {
 	void reload_text();
 	void set_warnings_panel(RichTextLabel *p_warnings_panel);
 
+	// TODO even necessary now?
+	void set_shader_dependency_tree(Tree* tree);
+	void update_shader_dependency_tree();
+
 	Ref<Shader> get_edited_shader() const;
 	void set_edited_shader(const Ref<Shader> &p_shader);
+	void set_edited_shader(const Ref<Shader> &p_shader, String code);
 	ShaderTextEditor();
 };
 
@@ -120,6 +129,10 @@ class ShaderEditor : public PanelContainer {
 
 	ShaderTextEditor *shader_editor;
 
+	Map<String, String> shader_rolling_code;
+	ShaderDependencyGraph shader_dependencies;
+	Tree *shader_dependency_tree;
+
 	void _menu_option(int p_option);
 	mutable Ref<Shader> shader;
 
@@ -132,6 +145,10 @@ class ShaderEditor : public PanelContainer {
 	void _warning_clicked(Variant p_line);
 	void _update_warnings(bool p_validate);
 
+	void _tree_activate_shader();
+	void _update_shader_dependency_tree();
+	void _update_shader_dependency_tree_items(TreeItem* parent_tree_item, ShaderDependencyNode* node);
+
 protected:
 	void _notification(int p_what);
 	static void _bind_methods();
diff --git a/servers/rendering/shader_preprocessor.cpp b/servers/rendering/shader_preprocessor.cpp
index dbced65b6b82..4534972568f3 100644
--- a/servers/rendering/shader_preprocessor.cpp
+++ b/servers/rendering/shader_preprocessor.cpp
@@ -881,6 +881,9 @@ bool operator==(ShaderDependencyNode left, ShaderDependencyNode right) {
 
 void ShaderDependencyGraph::populate(Ref<Shader> shader) {
 	cyclic_dep_tracker.clear();
+	nodes.clear(); // TODO actually delete these if we're refreshing
+	visited_shaders.clear();
+
 	ShaderDependencyNode* node = new ShaderDependencyNode(shader);
 	nodes.insert(node);
 	populate(node);
diff --git a/servers/rendering/shader_preprocessor.h b/servers/rendering/shader_preprocessor.h
index 87eae71fa72f..fc904bbac5aa 100644
--- a/servers/rendering/shader_preprocessor.h
+++ b/servers/rendering/shader_preprocessor.h
@@ -42,7 +42,7 @@
 #include "scene/resources/shader.h"
 
 class PreproprocessorTokenizer;
-class PPToken;
+struct PPToken;
 
 typedef char CharType;
 
